/**
 * Port Configuration Script
 * Adds custom port configuration to all Codai services
 */

const fs = require('fs');
const path = require('path');

// Port allocation mapping
const PORT_ALLOCATION = {
  // Foundation Tier (Priority 1)
  codai: 3000,
  memorai: 3001,
  logai: 3002,

  // Business Tier (Priority 2)
  bancai: 3010,
  wallet: 3011,
  fabricai: 3012,

  // User Tier (Priority 3)
  studiai: 3020,
  sociai: 3021,
  cumparai: 4009,

  // Specialized Tier (Priority 4)
  x: 3030,
  publicai: 3031,

  // Support Services
  admin: 3040,
  AIDE: 3041,
  ajutai: 3042,
  analizai: 3043,
  dash: 3044,
  docs: 3045,
  explorer: 3046,
  hub: 3047,
  id: 3048,
  jucai: 3049,
  kodex: 3050,
  legalizai: 3051,
  marketai: 3052,
  metu: 3053,
  mod: 3054,
  stocai: 3055,
  templates: 3056,
  tools: 3057,
};

// Service directory mapping
const SERVICE_DIRS = {
  // Apps
  codai: 'apps/codai',
  memorai: 'apps/memorai',
  logai: 'apps/logai',
  bancai: 'apps/bancai',
  wallet: 'apps/wallet',
  fabricai: 'apps/fabricai',
  studiai: 'apps/studiai',
  sociai: 'apps/sociai',
  cumparai: 'apps/cumparai',
  x: 'apps/x',
  publicai: 'apps/publicai',

  // Services
  admin: 'services/admin',
  AIDE: 'services/AIDE',
  ajutai: 'services/ajutai',
  analizai: 'services/analizai',
  dash: 'services/dash',
  docs: 'services/docs',
  explorer: 'services/explorer',
  hub: 'services/hub',
  id: 'services/id',
  jucai: 'services/jucai',
  kodex: 'services/kodex',
  legalizai: 'services/legalizai',
  marketai: 'services/marketai',
  metu: 'services/metu',
  mod: 'services/mod',
  stocai: 'services/stocai',
  templates: 'services/templates',
  tools: 'services/tools',
};

function addPortConfiguration(serviceName, serviceDir, port) {
  console.log(`\nüì¶ Configuring ${serviceName} (Port ${port})`);

  const serviceRoot = path.join(__dirname, '..', serviceDir);

  // Check if service directory exists
  if (!fs.existsSync(serviceRoot)) {
    console.log(`‚ö†Ô∏è  Service directory not found: ${serviceRoot}`);
    return false;
  }

  let configured = false;

  // 1. Update package.json dev script
  const packageJsonPath = path.join(serviceRoot, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));

      if (!packageJson.scripts) {
        packageJson.scripts = {};
      }

      // Update dev script with custom port
      if (packageJson.scripts.dev) {
        // Handle different frameworks
        if (packageJson.scripts.dev.includes('next dev')) {
          packageJson.scripts.dev = `next dev --port ${port}`;
        } else if (packageJson.scripts.dev.includes('vite')) {
          packageJson.scripts.dev = `vite --port ${port}`;
        } else if (packageJson.scripts.dev.includes('npm run')) {
          // Keep existing script but add port env var
          packageJson.scripts.dev = `PORT=${port} ${packageJson.scripts.dev}`;
        } else {
          packageJson.scripts.dev = `PORT=${port} ${packageJson.scripts.dev}`;
        }
      } else {
        // Default Next.js dev script
        packageJson.scripts.dev = `next dev --port ${port}`;
      }

      // Add start script with port
      packageJson.scripts.start =
        packageJson.scripts.start || `next start --port ${port}`;

      fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
      console.log(`‚úÖ Updated package.json`);
      configured = true;
    } catch (error) {
      console.log(`‚ùå Error updating package.json: ${error.message}`);
    }
  }

  // 2. Create/update .env.local
  const envLocalPath = path.join(serviceRoot, '.env.local');
  const envContent = `# ${serviceName.toUpperCase()} Port Configuration
PORT=${port}
NEXT_PUBLIC_PORT=${port}
NEXT_PUBLIC_APP_URL=http://localhost:${port}
NEXT_PUBLIC_API_URL=http://localhost:${port}/api

# Development Configuration
NODE_ENV=development
NEXT_PUBLIC_NODE_ENV=development

# Generated by port configuration script
CODAI_SERVICE_NAME=${serviceName}
CODAI_SERVICE_PORT=${port}
`;

  try {
    fs.writeFileSync(envLocalPath, envContent);
    console.log(`‚úÖ Created .env.local`);
    configured = true;
  } catch (error) {
    console.log(`‚ùå Error creating .env.local: ${error.message}`);
  }

  // 3. Create/update next.config.js if it's a Next.js app
  const nextConfigPath = path.join(serviceRoot, 'next.config.js');
  const nextConfigMjsPath = path.join(serviceRoot, 'next.config.mjs');

  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      const isNextJs =
        packageJson.dependencies?.next || packageJson.devDependencies?.next;

      if (
        isNextJs &&
        !fs.existsSync(nextConfigPath) &&
        !fs.existsSync(nextConfigMjsPath)
      ) {
        const nextConfigContent = `/** @type {import('next').NextConfig} */
const nextConfig = {
  // ${serviceName} Configuration
  env: {
    CUSTOM_PORT: '${port}',
    SERVICE_NAME: '${serviceName}',
  },
  
  // Development server configuration
  ...(process.env.NODE_ENV === 'development' && {
    async rewrites() {
      return [
        {
          source: '/api/:path*',
          destination: 'http://localhost:${port}/api/:path*',
        },
      ];
    },
  }),
  
  // Production optimization
  experimental: {
    optimizeCss: true,
  },
  
  // Output configuration
  output: 'standalone',
  
  // Performance optimization
  poweredByHeader: false,
  compress: true,
  
  // Security headers
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'Referrer-Policy',
            value: 'origin-when-cross-origin',
          },
        ],
      },
    ];
  },
};

module.exports = nextConfig;
`;

        fs.writeFileSync(nextConfigPath, nextConfigContent);
        console.log(`‚úÖ Created next.config.js`);
        configured = true;
      }
    } catch (error) {
      console.log(`‚ùå Error processing Next.js config: ${error.message}`);
    }
  }

  // 4. Create VS Code tasks
  const vscodeDir = path.join(serviceRoot, '.vscode');
  const tasksPath = path.join(vscodeDir, 'tasks.json');

  if (!fs.existsSync(vscodeDir)) {
    fs.mkdirSync(vscodeDir, { recursive: true });
  }

  const tasksContent = {
    version: '2.0.0',
    tasks: [
      {
        type: 'shell',
        label: `${serviceName}: Start Development Server`,
        command: 'npm',
        args: ['run', 'dev'],
        group: 'build',
        isBackground: true,
        problemMatcher: {
          pattern: {
            regexp: '^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$',
            file: 1,
            line: 2,
            column: 3,
            severity: 4,
            message: 5,
          },
          background: {
            activeOnStart: true,
            beginsPattern: '^.*starting.*$',
            endsPattern: '^.*ready.*$',
          },
        },
        presentation: {
          echo: true,
          reveal: 'always',
          focus: false,
          panel: 'shared',
          showReuseMessage: true,
          clear: false,
        },
      },
      {
        type: 'shell',
        label: `${serviceName}: Build`,
        command: 'npm',
        args: ['run', 'build'],
        group: 'build',
      },
      {
        type: 'shell',
        label: `${serviceName}: Test`,
        command: 'npm',
        args: ['test'],
        group: 'test',
      },
      {
        type: 'shell',
        label: `${serviceName}: Install Dependencies`,
        command: 'npm',
        args: ['install'],
        group: 'build',
      },
    ],
  };

  try {
    fs.writeFileSync(tasksPath, JSON.stringify(tasksContent, null, 2));
    console.log(`‚úÖ Created VS Code tasks`);
    configured = true;
  } catch (error) {
    console.log(`‚ùå Error creating VS Code tasks: ${error.message}`);
  }

  return configured;
}

function main() {
  console.log('üöÄ Starting Port Configuration for Codai Ecosystem');
  console.log(`üìä Total Services: ${Object.keys(PORT_ALLOCATION).length}`);

  let configured = 0;
  let skipped = 0;

  for (const [serviceName, port] of Object.entries(PORT_ALLOCATION)) {
    const serviceDir = SERVICE_DIRS[serviceName];

    if (!serviceDir) {
      console.log(`‚ö†Ô∏è  No directory mapping for ${serviceName}`);
      skipped++;
      continue;
    }

    if (addPortConfiguration(serviceName, serviceDir, port)) {
      configured++;
    } else {
      skipped++;
    }
  }

  console.log('\nüéØ Port Configuration Summary:');
  console.log(`‚úÖ Configured: ${configured}`);
  console.log(`‚ö†Ô∏è  Skipped: ${skipped}`);
  console.log(`üìä Total: ${configured + skipped}`);

  if (configured > 0) {
    console.log('\nüìù Next Steps:');
    console.log('1. Review .env.local files for each service');
    console.log('2. Update docker-compose.yml with new ports');
    console.log('3. Update browser test configuration');
    console.log('4. Test service startup with new ports');
  }
}

if (require.main === module) {
  main();
}

module.exports = {
  PORT_ALLOCATION,
  SERVICE_DIRS,
  addPortConfiguration,
};
