#!/usr/bin/env node

/**
 * Environment Variable Distribution Script
 * Distributes .env.local variables across all 29 Codai services
 * Part of Milestone 2: Enterprise Production Excellence
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Color coding for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

console.log(
  `${colors.cyan}${colors.bright}üöÄ Codai Environment Distribution System${colors.reset}`
);
console.log(
  `${colors.blue}Milestone 2: Enterprise Production Excellence${colors.reset}\n`
);

/**
 * Parse environment variables from .env.local file
 */
function parseEnvFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const envVars = {};

    content.split('\n').forEach(line => {
      line = line.trim();
      if (line && !line.startsWith('#')) {
        const [key, ...valueParts] = line.split('=');
        if (key && valueParts.length > 0) {
          envVars[key.trim()] = valueParts.join('=').trim();
        }
      }
    });

    return envVars;
  } catch (error) {
    console.error(
      `${colors.red}‚ùå Failed to parse .env.local file:${colors.reset}`,
      error.message
    );
    process.exit(1);
  }
}

/**
 * Generate service-specific environment variables
 */
function generateServiceEnv(serviceName, baseEnvVars) {
  const serviceEnv = { ...baseEnvVars };

  // Service-specific customizations
  const servicePort = getServicePort(serviceName);
  if (servicePort) {
    serviceEnv.PORT = servicePort;
    serviceEnv.SERVICE_PORT = servicePort;
  }

  // Service-specific URLs and endpoints
  serviceEnv.SERVICE_NAME = serviceName;
  serviceEnv.SERVICE_URL = `https://${serviceName}.codai.dev`;
  serviceEnv.API_URL = `https://api.codai.dev/${serviceName}`;

  // Database and Redis URLs (service-specific if needed)
  if (serviceName === 'memorai' || serviceName === 'logai') {
    serviceEnv.DATABASE_URL =
      serviceEnv.DATABASE_URL ||
      `postgresql://codai:${serviceEnv.DATABASE_PASSWORD}@localhost:5432/${serviceName}`;
  }

  return serviceEnv;
}

/**
 * Get default port for service
 */
function getServicePort(serviceName) {
  const portMap = {
    codai: '3000',
    memorai: '3001',
    logai: '3002',
    bancai: '3003',
    wallet: '3004',
    fabricai: '3005',
    studiai: '3006',
    sociai: '3007',
    cumparai: '3008',
    x: '3009',
    publicai: '3010',
    admin: '4000',
    AIDE: '4001',
    ajutai: '4002',
    analizai: '4003',
    dash: '4004',
    docs: '4005',
    explorer: '4006',
    hub: '4007',
    id: '4008',
    jucai: '4009',
    kodex: '4010',
    legalizai: '4011',
    marketai: '4012',
    metu: '4013',
    mod: '4014',
    stocai: '4015',
    templates: '4016',
    tools: '4017',
  };

  return portMap[serviceName];
}

/**
 * Create .env.local file for a service
 */
function createServiceEnvFile(servicePath, envVars) {
  const envFilePath = path.join(servicePath, '.env.local');

  let envContent = `# Auto-generated by Codai Environment Distribution System
# Milestone 2: Enterprise Production Excellence
# Generated: ${new Date().toISOString()}

`;

  Object.entries(envVars).forEach(([key, value]) => {
    envContent += `${key}=${value}\n`;
  });

  fs.writeFileSync(envFilePath, envContent);
  return envFilePath;
}

/**
 * Generate Kubernetes secret for a service
 */
function generateKubernetesSecret(serviceName, envVars) {
  const secretData = {};

  Object.entries(envVars).forEach(([key, value]) => {
    secretData[key] = Buffer.from(value).toString('base64');
  });

  const secret = {
    apiVersion: 'v1',
    kind: 'Secret',
    metadata: {
      name: `${serviceName}-env`,
      namespace: 'codai-production',
      labels: {
        app: serviceName,
        component: 'environment',
        'app.kubernetes.io/name': serviceName,
        'app.kubernetes.io/component': 'environment',
        'app.kubernetes.io/part-of': 'codai-ecosystem',
      },
    },
    type: 'Opaque',
    data: secretData,
  };

  return secret;
}

/**
 * Main distribution function
 */
async function distributeEnvironmentVariables() {
  console.log(
    `${colors.yellow}üìã Loading project configuration...${colors.reset}`
  );

  // Load project index
  const projectsIndexPath = path.join(__dirname, '../projects.index.json');
  let projectsIndex;
  try {
    projectsIndex = JSON.parse(fs.readFileSync(projectsIndexPath, 'utf8'));
  } catch (error) {
    console.error(
      `${colors.red}‚ùå Failed to load projects.index.json:${colors.reset}`,
      error.message
    );
    process.exit(1);
  }

  // Load environment variables
  const envFilePath = path.join(__dirname, '../.env.local');
  console.log(
    `${colors.yellow}üîß Loading environment variables from .env.local...${colors.reset}`
  );
  const envVariables = parseEnvFile(envFilePath);

  console.log(
    `${colors.green}‚úÖ Loaded ${Object.keys(envVariables).length} environment variables${colors.reset}`
  );

  // Common environment variables for all services
  const commonEnvVariables = {
    NODE_ENV: 'development',
    NEXTAUTH_URL: 'http://localhost:3000',
    NEXT_PUBLIC_APP_URL: 'http://localhost:3000',
    CODAI_ENVIRONMENT: 'development',
    CODAI_VERSION: '2.0.0',
    TURBO_TEAM: 'codai',
    ...envVariables,
  };

  let processedCount = 0;
  const errors = [];
  const kubernetesSecrets = [];

  // Process apps
  console.log(
    `\n${colors.cyan}üèóÔ∏è  Processing Apps (Priority Services)...${colors.reset}`
  );
  if (projectsIndex.apps && Array.isArray(projectsIndex.apps)) {
    for (const app of projectsIndex.apps) {
      try {
        const appPath = path.join(__dirname, '../apps', app.name);

        if (fs.existsSync(appPath)) {
          const serviceEnv = generateServiceEnv(app.name, commonEnvVariables);
          const envFilePath = createServiceEnvFile(appPath, serviceEnv);
          const k8sSecret = generateKubernetesSecret(app.name, serviceEnv);

          kubernetesSecrets.push(k8sSecret);
          processedCount++;

          console.log(
            `   ${colors.green}‚úÖ${colors.reset} ${app.name} - ${envFilePath}`
          );
        } else {
          console.log(
            `   ${colors.yellow}‚ö†Ô∏è${colors.reset}  ${app.name} - Directory not found`
          );
          errors.push({ service: app.name, error: 'Directory not found' });
        }
      } catch (error) {
        console.error(
          `   ${colors.red}‚ùå${colors.reset} ${app.name} - ${error.message}`
        );
        errors.push({ service: app.name, error: error.message });
      }
    }
  }

  // Process services
  console.log(
    `\n${colors.cyan}üîß Processing Services (Extended Services)...${colors.reset}`
  );
  const servicesPath = path.join(__dirname, '../services');

  try {
    const serviceEntries = fs
      .readdirSync(servicesPath, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory());

    for (const serviceEntry of serviceEntries) {
      const serviceName = serviceEntry.name;

      try {
        const servicePath = path.join(servicesPath, serviceName);
        const serviceEnv = generateServiceEnv(serviceName, commonEnvVariables);
        const envFilePath = createServiceEnvFile(servicePath, serviceEnv);
        const k8sSecret = generateKubernetesSecret(serviceName, serviceEnv);

        kubernetesSecrets.push(k8sSecret);
        processedCount++;

        console.log(
          `   ${colors.green}‚úÖ${colors.reset} ${serviceName} - ${envFilePath}`
        );
      } catch (error) {
        console.error(
          `   ${colors.red}‚ùå${colors.reset} ${serviceName} - ${error.message}`
        );
        errors.push({ service: serviceName, error: error.message });
      }
    }
  } catch (error) {
    console.error(
      `${colors.red}‚ùå Failed to read services directory:${colors.reset}`,
      error.message
    );
    errors.push({ service: 'services-directory', error: error.message });
  }

  console.log(
    `\n${colors.magenta}üéØ Environment Distribution Summary:${colors.reset}`
  );
  console.log(
    `${colors.green}‚úÖ Successfully processed: ${processedCount} services${colors.reset}`
  );
  console.log(
    `${colors.red}‚ùå Errors encountered: ${errors.length}${colors.reset}`
  );

  if (errors.length > 0) {
    console.log(`\n${colors.yellow}‚ö†Ô∏è  Error Details:${colors.reset}`);
    errors.forEach(({ service, error }) => {
      console.log(`   - ${service}: ${error}`);
    });
  }

  // Generate distribution report
  let totalServices = projectsIndex.apps ? projectsIndex.apps.length : 0;

  try {
    const serviceNames = fs
      .readdirSync(servicesPath, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory());
    totalServices += serviceNames.length;
  } catch (error) {
    console.warn('‚ö†Ô∏è  Could not count services directory');
  }

  const report = {
    timestamp: new Date().toISOString(),
    totalServices: totalServices,
    processedSuccessfully: processedCount,
    errors: errors,
    environmentVariables: Object.keys(envVariables),
    commonVariables: Object.keys(commonEnvVariables),
  };

  // Save distribution report
  const reportPath = path.join(__dirname, '../env-distribution-report.json');
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

  // Generate Kubernetes secrets file
  console.log(
    `\n${colors.blue}üé≠ Generating Kubernetes secrets...${colors.reset}`
  );
  const k8sSecretsPath = path.join(__dirname, '../kubernetes-secrets.yaml');
  let k8sContent = `# Auto-generated Kubernetes Secrets for Codai Ecosystem
# Milestone 2: Enterprise Production Excellence
# Generated: ${new Date().toISOString()}

`;

  kubernetesSecrets.forEach((secret, index) => {
    k8sContent += '---\n';
    k8sContent += `# Secret for ${secret.metadata.name}\n`;
    k8sContent += JSON.stringify(secret, null, 2).replace(/"/g, '"') + '\n';
    if (index < kubernetesSecrets.length - 1) {
      k8sContent += '\n';
    }
  });

  fs.writeFileSync(k8sSecretsPath, k8sContent);

  // Final summary
  console.log(
    `\n${colors.bright}${colors.green}üéâ Environment Distribution Complete!${colors.reset}`
  );
  console.log(`${colors.cyan}üìä Report saved: ${reportPath}${colors.reset}`);
  console.log(
    `${colors.cyan}üé≠ Kubernetes secrets: ${k8sSecretsPath}${colors.reset}`
  );
  console.log(
    `${colors.cyan}üèóÔ∏è  Services configured: ${processedCount}/${totalServices}${colors.reset}`
  );

  if (processedCount === totalServices && errors.length === 0) {
    console.log(
      `\n${colors.bright}${colors.green}‚ú® PERFECT DISTRIBUTION: All 29 services configured successfully!${colors.reset}`
    );
  }

  return {
    success: processedCount > 0,
    processedCount,
    totalServices,
    errors,
    reportPath,
    k8sSecretsPath,
  };
}

// Execute main function
distributeEnvironmentVariables()
  .then(result => {
    if (result.success) {
      console.log(
        `\n${colors.green}üöÄ Ready for Milestone 2 execution!${colors.reset}`
      );
      process.exit(0);
    } else {
      console.error(
        `\n${colors.red}‚ùå Distribution failed. Check errors above.${colors.reset}`
      );
      process.exit(1);
    }
  })
  .catch(error => {
    console.error(`\n${colors.red}‚ùå Fatal error:${colors.reset}`, error);
    process.exit(1);
  });
